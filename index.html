<html>


<head>
    <title>INFO 3300 - project1</title>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>

    <style>
      body {
    font-family: 'Open Sans', sans-serif;
    margin: 0;
    padding: 0;
}

.layout-container {
    display: flex;
    flex-direction: row;
    gap: 20px;
    width: 100%;
    height: 100%;
    padding: 20px;
    box-sizing: border-box;
}

.column {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.map-container,
.graph-container {
    background-color: #f9f9f9;
    border: 1px solid #ddd;
    padding: 10px;
    border-radius: 5px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

        .histogram {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            width: 100%;
            margin: auto;
        } 

        .slider-line {
            stroke: #d3d3d3;
            stroke-width: 6;
            stroke-linecap: round;
        }

        .tick-text {
            font-size: 14px;
            fill: #333;
        }

        .slider-handle {
            fill: #4CAF50;
            stroke: #ffffff;
            stroke-width: 2;
            cursor: pointer;
        }

        .slider-handle:hover {
            fill: #388E3C;
        }

        #scatter-legend {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 10px;
            font-family: 'Open Sans', sans-serif;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 3px;
        }

        .scatter-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .division {

            fill: lightgrey;
        }

        .outline {
            fill: none;
            stroke: rgb(0, 0, 0);
            stroke-width: 1px;
        }

        .graticule {
            fill: none;
            stroke: grey;
            stroke-width: 1px;
        }

        .tooltip {
            pointer-events: none;
        }

        .mouseover_outline {
            pointer-events: none;
            fill: none;
        }
    </style>
</head>

<body>
    <!-- Basic HTML -->
    <h1>US Building Energy Consumption Analysis</h1>
    <p id="member">Amber Su, Chi Zhang, Kewei Xu</p>


    <div class="radio-group">
        <label>
            <input type="radio" name="energyMetric" value="NormalizedGasKWh">
            NormalizedGasKWh
        </label>
        <label>
            <input type="radio" name="energyMetric" value="NormalizedElecKWh">
            NormalizedElecKWh
        </label>
        <label>
            <input type="radio" name="energyMetric" value="NormalizedHeatKWh">
            NormalizedHeatKWh
        </label>
        <label>
            <input type="radio" name="energyMetric" value="NormalizedCoolKWh">
            NormalizedCoolKWh
        </label>
    </div>


    <div id="slider-container"></div>

    <div>
        <label for="xSelect">X-axis:</label>
        <select id="scatter-xSelect" onchange="updateAxes()">
            <option value="NormalizedGasKWh">Normalized Gas (kWh)</option>
            <option value="NormalizedElecKWh">Normalized Electricity (kWh)</option>
            <option value="NormalizedHeatKWh">Normalized Heat (kWh)</option>
            <option value="NormalizedCoolKWh">Normalized Cooling (kWh)</option>
            <option value="SQM">Building Area </option>
        </select>

    </div>

    <div class="layout-container">
        <!-- First Column -->
        <div class="column">
            <div id="commercial-map" class="map-container">
                <svg id="map1" height="300" width="450"></svg>
            </div>
            <div id="residential-map" class="map-container">
                <svg id="map2" height="300" width="450"></svg>
            </div>
        </div>
    
        <!-- Second Column -->
        <div class="column">
            <div id="commercial-histogram" class="graph-container">
                <svg id="hist1" width="450" height="150"></svg>
            </div>
            <div id="commercial-scatter" class="graph-container">
                <svg id="scatter-cbecs" width="450" height="150"></svg>
            </div>
            <div id="residential-histogram" class="graph-container">
                <svg id="hist2" width="450" height="150"></svg>
            </div>
            <div id="residential-scatter" class="graph-container">
                <svg id="scatter-recs" width="450" height="150"></svg>
            </div>
        </div>
    </div>
    


    <!-- Script -->
    <!-- Global Script -->
    <script>


        async function loadData() {
            const cbecs = await d3.csv("Data/cleaned_cbecs.csv", d3.autoType);
            const recs = await d3.csv("Data/cleaned_recs.csv", d3.autoType);
            return { cbecs, recs };
        }

        //FOR both histogram and map
        const colorMap = {
            "NormalizedGasKWh": "#ed9352",
            "NormalizedElecKWh": "#ffc815",
            "NormalizedHeatKWh": "#c00000",
            "NormalizedCoolKWh": "#6893ee"
        };



        //NOTE: This should be managed globally to get the input from user
        //For both RECS and CBECS
        var CommonFilters = {};


        function selectRange(data, key, min, max) {
            return data[key] >= min && data[key] <= max;
        }

        function setMinMaxFilter(key, min, max) {
            CommonFilters[key] = function (data) {
                return data[key] >= min && data[key] <= max;
            };
        }

        function setMatchFilter(key, valueList) {
            CommonFilters[key] = function (data) {
                return valueList.includes(data[key]);
            };
        }

        //Selected data based on the filters
        function selectData(data, filters) {
            return data.filter(d => {
                passed = true;
                Object.values(CommonFilters).forEach(filter => {
                    passed = passed && filter(d);
                });
                return passed;
            });
        }


        //setInitialFilter
        setMinMaxFilter("YRCONC", 0, 4);
        setMinMaxFilter("SQM", 0, 50000);
        setMatchFilter("DIVISION", [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);

    </script>

    <!-- histogram Plot -->
    <script id="histogram">

        var svg_hist1 = d3.select("#hist1");
        const hist_width = svg_hist1.attr("width");
        const hist_height = svg_hist1.attr("height");
        const hist_margin = { top: 40, right: 20, bottom: 20, left: 50 };
        const hist_innerWidth = hist_width - hist_margin.left - hist_margin.right;
        const hist_innerHeight = hist_height - hist_margin.top - hist_margin.bottom;
        const hist_svgElements = ["hist1", "hist2"]

        const hist_title = ["Distribution of Residential Buildings by Energy Consumption","Distribution of Commercial Buildings by Energy Consumption"]



        function HistoData(data, xRange, numBins = 60) {

            let histogram = d3.histogram()
                .domain(xRange)
                .thresholds(d3.range(xRange[0], xRange[1], (xRange[1] - xRange[0]) / numBins));

            let counts = histogram(data);

            return counts;
        }


        function drawHistogram(svg_data_dict, color) {

            const xRange = [0, 600];

            var countsArray = svg_data_dict.map(d => HistoData(d.data, xRange, 60));

            const xScale = d3.scaleLinear()
                .domain(xRange)
                .range([0, hist_innerWidth]);

            const xAxis = d3.axisBottom(xScale);


            svg_data_dict.forEach((d, i) => {
                //let yRanges = countsArray.map(c => d3.extent(c, d => d.length));

                const svg_id = d.svg;
                var data = d.data;
                var chartData = countsArray[i];

                var yRange = d3.extent(chartData, d => d.length);
                var yScale = d3.scaleLinear()
                    .domain([0, yRange[1]])
                    .range([hist_innerHeight, 0]);

                var yAxis = d3.axisLeft(yScale);

                //chartData = chartData.filter(d => d.length > 50);



                const svg = d3.select(`#${svg_id}`);

                svg.append("g")
                    .append("text")
                    .attr("class","title")
                    .attr("transform", `translate(${hist_width / 2}, ${hist_margin.top / 2})`)
                    .attr("text-anchor", "middle")
                    .text(hist_title[i]);
                    

                const chartArea = svg.append("g")
                    .attr("transform", `translate(${hist_margin.left}, ${hist_margin.top})`);


                svg.append("g")
                    .attr("class", "hist_axis")
                    .attr("transform", `translate(${hist_margin.left}, ${hist_innerHeight + hist_margin.top})`)
                    .call(xAxis);

                svg.append("g")
                    .attr("class", "hist_axis")
                    .attr("transform", `translate(${hist_margin.left}, ${hist_margin.top})`)
                    .call(yAxis);

                const tooltip = d3.select("body")
                    .append("div")
                    .style("position", "absolute")
                    .style("visibility", "hidden")
                    .style("background", "rgba(255, 255, 255, 0.9)")
                    .style("padding", "4px")
                    .style("border-radius", "2px")
                    .style("font-size", "12px")
                    .style("color", "#333");


                chartArea.selectAll("rect.hist").data(chartData)
                    .join("rect")
                    .attr("class", "hist")
                    .attr("x", d => xScale(d.x0) + 1)
                    .attr("y", d => yScale(d.length))
                    .attr("width", d => xScale(d.x1) - xScale(d.x0))
                    .attr("height", d => yScale(0) - yScale(d.length))
                    .attr("fill", color)
                    .attr("opacity", 0.7)
                    .attr("stroke", "#ffffff")
                    .attr("stroke-width", 1)
                    .on("mouseover", function (event, d) {
                        d3.select(this).attr("opacity", 1)
                            .transition()
                            .duration(100);

                        tooltip
                            .style("visibility", "visible")
                            .html(`Count: ${d.length} <br> Range: ${d.x0} - ${d.x1} kWh/m&sup2`);
                    })
                    .on("mousemove", function (event) {
                        tooltip
                            .style("top", `${event.pageY + 10}px`)
                            .style("left", `${event.pageX + 10}px`);
                    })
                    .on(
                        "mouseout",
                        function (event, d) {
                            d3.select(this).attr("opacity", 0.7)
                                .transition()
                                .duration(100)
                                .attr("stroke", "#ffffff")
                                .attr("stroke-width", 1)

                            tooltip.style("visibility", "hidden");
                        }
                    )

            })

        }


        function updateHistogram(ComData, ResData, value) {
            color = colorMap[value];
            const combinedData = [ComData.map(d => d[value]), ResData.map(d => d[value])];
            Array.from(hist_svgElements).forEach(svg => {
                const svg_op = document.querySelector(`#${svg}`);
                while (svg_op.firstChild) {
                    svg_op.removeChild(svg_op.firstChild);
                }
            });

            svg_data = Array.from(hist_svgElements).map((svg, index) => ({
                svg: svg,
                data: combinedData[index]
            }));

            drawHistogram(svg_data, color);
        }



    </script>

    <!-- Script -->
    <script id="graph-load">
        loadData().then(data => {
            //GLOBAL INTIAL CONFIGURATION 
            var visDataKey = "NormalizedElecKWh";
            const { cbecs, recs } = data;
            var filtered_cbecs = cbecs;
            var filtered_recs = recs;

            //SCATTER PLOT ONLY
            let scatterXVar = "NormalizedGasKWh";
            let scatterYVar = "NormalizedElecKWh";
            let scatterColorMetric = "DIVISION";

            d3.selectAll(".radio-group input[type='radio']")
                .on("click", function () {
                    const selectedValue = d3.select(this).attr("value");
                    scatterYVar = selectedValue;
                    selectValue(selectedValue);
                });

            d3.select("#scatter-xSelect").on("change", function () {
                scatterXVar = d3.select(this).property("value");
                updateAllScatterPlots();
            });

            const scatterColorScale = d3.scaleOrdinal()
                .domain([...new Set([...cbecs.map(d => d.DIVISION), ...recs.map(d => d.DIVISION)])])
                .range(d3.schemeCategory10);

            const scatterConfigs = [
                { id: "scatter-cbecs", title: "Commercial Building", data: filtered_cbecs },
                { id: "scatter-recs", title: "Residential Building", data: filtered_recs }
            ];

            const scatterContexts = scatterConfigs.map(config =>
                drawScatter(config.id, config.title, config.data)
            );
            //END OF SCATTER PLOT ONLY



            //UPDATE FOR FILTERS
            function updateFilter() {
                filtered_cbecs = selectData(cbecs, CommonFilters);
                filtered_recs = selectData(recs, CommonFilters);
                updateHistogram(filtered_cbecs, filtered_recs, visDataKey);
                updateAllScatterPlots();

                //CHI PUT YOUR GRAPH UPDATE HERE

                //IDEALLY IT SHOULD JUST CHANGE THE COLOR, NOT REDRAW EVERYTHING
            }

            //NOTE FOR CURTIS
            //MAYBE TURN EVEYRTHING INTO VARIABLE AND MOVE OUT OF GLOBAL
            function updateAllScatterPlots() {
                const highlightedDivision = 3; // need to take Chi's input here!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

                scatterContexts.forEach((context, index) => {
                    const filteredData = index === 0 ? filtered_cbecs : filtered_recs; // Use filtered datasets
                    updateScatter(
                        context,
                        filteredData, // Pass filtered data
                        scatterXVar,
                        scatterYVar,
                        scatterColorScale,
                        highlightedDivision,
                        scatterColorMetric
                    );
                });
            }


            //UPDATE FOR WHICH VALUE TO DISPLAY
            function selectValue(value) {
                visDataKey = value;


                updateHistogram(filtered_cbecs, filtered_recs, visDataKey);
                updateAllScatterPlots();

                //CHI: PUT YOUR GRAPH UPDATE HRE

                //HERE IT SHOULD UPDATE FOR WHICH DATA TO SHOW (GAS, ELEC, HEAT, COOL)
                //IDEALLY IT SHOULD JUST CHANGE THE COLOR, NOT REDRAW EVERYTHING
                const combinedData_map = [filtered_cbecs.map(d => ({ value: d[value], division: d.DIVISION})), 
                filtered_recs.map(d => ({value: d[value], division: d.DIVISION}))];

                updateMap(combinedData_map, colorMap[value]);
            }



            //global controller (must be in scope)
            //LISTEN TO EVENT AND UPDATE FILTER
            //WILL CALL updateFilter() WITH UPDATED FILTER
            function drawSlider() {
                const slider_width = 500;
                const slider_height = 100;
                const slider_margin = { top: 20, right: 40, bottom: 50, left: 30 };
                const areaExtent = [50, 50000];

                const area_slider = d3.select("#slider-container")
                    .append("svg")
                    .attr("id", "area_slider")
                    .attr("width", slider_width)
                    .attr("height", slider_height);

                const areaScale = d3.scaleLog()
                    .domain(areaExtent)
                    .range([slider_margin.left, slider_width - slider_margin.right]);

                const arealabels = [50, 500, 5000, 20000, 50000];

                console.log("area labels", arealabels);

                area_slider.selectAll(".area-tick-text")
                    .data(arealabels)
                    .join("text")
                    .attr("class", "area-tick-text")
                    .attr("x", d => areaScale(d))
                    .attr("y", slider_height / 2 + 30)
                    .attr("text-anchor", "middle")
                    .text(d => d);

                area_slider.append("line")
                    .attr("class", "slider-line")
                    .attr("x1", slider_margin.left)
                    .attr("x2", slider_width - slider_margin.right)
                    .attr("y1", slider_height / 2)
                    .attr("y2", slider_height / 2);

                area_slider.selectAll(".area-tick")
                    .data(arealabels)
                    .join("circle")
                    .attr("class", "area-tick")
                    .attr("cx", d => areaScale(d))
                    .attr("cy", slider_height / 2)
                    .attr("r",  5) 
                    .attr("fill", "gray");

               

                const coloredLine = area_slider.append("line")
                    .attr("class", "colored-line")
                    .attr("x1", areaScale(areaExtent[0]))
                    .attr("x2", areaScale(areaExtent[1]))
                    .attr("y1", slider_height / 2)
                    .attr("y2", slider_height / 2)
                    .attr("stroke", "steelblue")
                    .attr("stroke-width", 4);

                let startingPos = [areaExtent[0], areaExtent[1]];


                const area_handles = area_slider.selectAll(".area-slider-handle")
                    .data([0, 1])
                    .enter()
                    .append("circle")
                    .attr("class", "area-slider-handle")
                    .attr("r", 10)
                    .attr("cx", d => areaScale(startingPos[d]))
                    .attr("cy", slider_height / 2)
                    .call(d3.drag()
                        .on("drag", function (event, d) {
                            console.log(d);


                            var newPos = areaScale.invert(event.x);

                            if (d === 0) {
                                newPos = Math.max(areaExtent[0], Math.min(newPos, startingPos[1] / 1.1));
                            } else if (d === 1) {
                                newPos = Math.min(areaExtent[1], Math.max(newPos, startingPos[0] * 1.1));
                            }
                            // if (newPos > 1) {
                            //     newPos = 1;
                            // } else if (newPos < 0) {
                            //     newPos = 0;
                            // }

                            startingPos[d] = newPos;


                            d3.select(this).attr("cx", areaScale(newPos));

                            coloredLine
                                .attr("x1", areaScale(startingPos[0]))
                                .attr("x2", areaScale(startingPos[1]));


                            //updateRangeText();
                        })
                        .on("end", function (event, d) {
                            setMinMaxFilter("SQM", startingPos[0] , startingPos[1]);
                            updateFilter();
                            //updateHistogram(combinedData, colorMap[value]);
                            //updateAllScatterPlots();
                        })
                    );


                const yrtickLabels = ["Pre 1960", "1960", "1980", "2000", "Post 2000"];
                const yrticks = d3.range(0, 4);

                const yrsvg = d3.select("#slider-container")
                    .append("svg")
                    .attr("width", slider_width)
                    .attr("height", slider_height);

                const yrxScale = d3.scaleLinear()
                    .domain([0, yrticks.length ])
                    .range([slider_margin.left, slider_width - slider_margin.right]);

                yrsvg.append("line")
                    .attr("class", "slider-line")
                    .attr("x1", yrxScale(0))
                    .attr("x2", yrxScale(yrticks.length ))
                    .attr("y1", slider_height / 2)
                    .attr("y2", slider_height / 2);

                yrsvg.selectAll(".yr-tick-text")
                    .data(yrtickLabels)
                    .enter()
                    .append("text")
                    .attr("class", "yr-tick-text")
                    .attr("x", (d, i) => yrxScale(i))
                    .attr("y", slider_height / 2 + 30)
                    .attr("text-anchor", "middle")
                    .text(d => d);

                yrsvg.selectAll(".yr-tick")
                    .data([0,1,2,3,4])
                    .join("circle")
                    .attr("class", "area-tick")
                    .attr("cx", d => yrxScale(d))
                    .attr("cy", slider_height / 2)
                    .attr("r",  5) 
                    .attr("fill", "gray");


                const yrcoloredLine = yrsvg.append("line")
                    .attr("class", "colored-line")
                    .attr("x1", yrxScale(0))
                    .attr("x2", yrxScale(4))
                    .attr("y1", slider_height / 2)
                    .attr("y2", slider_height / 2)
                    .attr("stroke", "steelblue")
                    .attr("stroke-width", 4);

                let handlePositions = [0, 4];

                yrsvg.selectAll(".slider-handle")
                    .data([0, 1])
                    .enter()
                    .append("circle")
                    .attr("class", "slider-handle")
                    .attr("r", 10)
                    .attr("cx", d => yrxScale(handlePositions[d]))
                    .attr("cy", slider_height / 2)
                    .call(d3.drag()
                        .on("drag", function (event, d) {
                            const newPos = Math.max(0, Math.min(yrticks.length, Math.round(yrxScale.invert(event.x))));
                            if (d === 0 && newPos >= handlePositions[1]) {
                                handlePositions[d] = handlePositions[1] - 1;
                            } else if (d === 1 && newPos <= handlePositions[0]) {
                                handlePositions[d] = handlePositions[0] + 1;
                            } else {
                                handlePositions[d] = newPos;
                            }
                            d3.select(this).attr("cx", yrxScale(handlePositions[d]));
                            setMinMaxFilter("YRCONC", handlePositions[0], handlePositions[1]-1);
                            updateFilter();

                            yrcoloredLine
                                .attr("x1", yrxScale(handlePositions[0]))
                                .attr("x2", yrxScale(handlePositions[1]));
                        })
                    );
            }

            //LATER LET'S CHECK HOW TO BEST HANDLE DIVISION SELECTIOn


            //INITIAL DRAWING HERE!
            selectValue(visDataKey);
            drawSlider();
        });
    </script>


    <!-- Scatter Plot Script -->
    <script id="scatter">
        function drawScatter(id, title, data) {
            const svg = d3.select(`#${id}`);
            const width = +svg.attr("width");
            const height = +svg.attr("height");
            const margin = { top: 50, right: 30, bottom: 40, left: 50 };
            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;

            const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

            svg.append("text")
                .attr("x", width / 2)
                .attr("y", margin.top / 2)
                .attr("text-anchor", "middle")
                .style("font-size", "16px")
                .text(title);

            const xScale = d3.scaleLinear().range([0, innerWidth]);
            const yScale = d3.scaleLinear().range([innerHeight, 0]);

            const xAxisGroup = g.append("g").attr("transform", `translate(0,${innerHeight})`);
            const yAxisGroup = g.append("g");

            return {
                g,
                xScale,
                yScale,
                xAxisGroup,
                yAxisGroup,
                innerWidth,
                innerHeight,
                margin
            };
        }
        function updateScatter(context, data, xVar, yVar, scatterColorScale, highlightedDivision, colorMetric) {
            const { g, xScale, yScale, xAxisGroup, yAxisGroup } = context;

            // Filter out invalid data where x or y is not finite or equals 0
            const filteredData = data.filter(d =>
                Number.isFinite(d[xVar]) &&
                Number.isFinite(d[yVar]) &&
                d[xVar] !== 0 &&
                d[yVar] !== 0
            );

            const tooltip = d3.select("body").append("div")
                .attr("class", "scatter-tooltip")
                .style("position", "absolute")
                .style("background", "rgba(0, 0, 0, 0.7)")
                .style("color", "#fff")
                .style("padding", "5px 10px")
                .style("border-radius", "5px")
                .style("pointer-events", "none")
                .style("opacity", 0);

            xScale.domain(d3.extent(filteredData, d => d[xVar])).nice();
            yScale.domain([0,600]);

            xAxisGroup.call(d3.axisBottom(xScale).ticks(6).tickFormat(d3.format(".2s")));
            yAxisGroup.call(d3.axisLeft(yScale).ticks(6).tickFormat(d3.format(".2s")));

            const circles = g.selectAll("circle")
                .data(filteredData, d => d[colorMetric]);

            circles.enter().append("circle")
                .merge(circles)
                .attr("cx", d => xScale(d[xVar]))
                .attr("cy", d => yScale(d[yVar]))
                .attr("r", 4)
                .attr("fill", d =>
                    d[colorMetric] === highlightedDivision
                        ? scatterColorScale(d[colorMetric])
                        : "#d3d3d3"
                )
                .attr("stroke", d =>
                    d[colorMetric] === highlightedDivision
                        ? "white"
                        : "none"
                )
                .attr("opacity", d =>
                    d[colorMetric] === highlightedDivision ? 1 : 0.3)
                .on("mouseover", (event, d) => {
                    tooltip.style("opacity", 1)
                        .html(`
                    <strong>${colorMetric}: </strong>${d[colorMetric]}<br>
            <strong>${xVar}: </strong>${d[xVar].toFixed(2)}<br>
            <strong>${yVar}: </strong>${d[yVar].toFixed(2)}
                `);
                })
                .on("mousemove", event => {
                    tooltip.style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 20) + "px");
                })
                .on("mouseout", () => {
                    tooltip.style("opacity", 0);
                });


            circles.exit().remove();

            // Bring highlighted circles to the top
            g.selectAll("circle")
                .filter(d => d[colorMetric] === highlightedDivision)
                .each(function () {
                    this.parentNode.appendChild(this);
                });
        }

    </script>

    <script id="map">
        
        var svg_map = d3.select("#map1");
        const map_width = svg_map.attr("width");
        const map_height = svg_map.attr("height");
        const map_margin = { top: 20, right: 20, bottom: 20, left: 20 };
        const map_Width = map_width - map_margin.left - map_margin.right;
        const map_Height = map_height - map_margin.top - map_margin.bottom;
        const map_svgElements = ["map1", "map2"]
        console.log(map_width)
        


        function drawMap(svg_data, color) {
            const requestData = async function () {
                const us = await d3.json("Data/censusDiv.topojson", d3.autoType);
                console.log("us");
                console.log(us);

                var divisions = topojson.feature(us, us.objects.data);
               

                var divisionsMesh = topojson.mesh(us, us.objects.data);
                
                var projection = d3.geoAlbersUsa().fitSize([map_Width, map_Height], divisions);
                //var projection = d3.geoAlbersUsa().fitExtent([[20, 20], [880, 580]], divisions);
                var path = d3.geoPath().projection(projection);

                let graticule = d3.geoGraticule10();


                
                var divisionDict = {};
                const divisionNumberName = {
                    1: "New England",
                    2: "Middle Atlantic",
                    3: "East North Central",
                    4: "West North Central",
                    5: "South Atlantic",
                    6: "East South Central",
                    7: "West South Central",
                    8: "Mountain",
                    9: "Pacific"
                }
                svg_data.forEach(set => {
                    const setSource = set.svg;
                    if (!divisionDict[setSource]) {
                        divisionDict[setSource] = {};
                    }
                    set.data.forEach(pair => {
                        const value = pair.value;
                        let division = pair.division;
                        if (typeof division === "number") {
                            division = divisionNumberName[division];
                        }
                        if (division === "Mountain North" || division === "Mountain South") {
                            division = "Mountain";
                        }

                        if (!divisionDict[setSource][division]) {
                            divisionDict[setSource][division] = { source: setSource, sum: 0, count: 0, average: 0 };
                        }
                        divisionDict[setSource][division].sum += value;
                        divisionDict[setSource][division].count += 1;
                    })

                    //average
                    Object.keys(divisionDict[setSource]).forEach(division => {
                        divisionDict[setSource][division].average = divisionDict[setSource][division].sum / divisionDict[setSource][division].count;
                    })

                })


                let extent = [];
                let extentTotal = [];
                
                Object.keys(divisionDict).forEach(map => {
                    const elements = Object.values(divisionDict[map]);
                    const minMax = d3.extent(elements, d => d.average)
                    extent.push(minMax);
                });

                
                //total extent
                extentTotal= [
                    Math.min(extent[0][0], extent[1][0]),
                    Math.max(extent[0][1], extent[1][1])
                ]
                //opacity Scale
                const opacityScale = d3.scaleQuantile()
                        .domain(extentTotal)
                        .range([1/6, 2/6, 3/6, 4/6, 5/6, 1]);
                
                const maps = {};

                svg_data.forEach((svg, index) => {
                    const currsvg = d3.select(`#${svg.svg}`);

                    const currDivisionDic = divisionDict[svg.svg];

                    const opacityMap ={};
                    Object.keys(currDivisionDic).forEach(division =>{
                        opacityMap[division]=opacityScale(currDivisionDic[division].average);
                    });
            

                    const tooltip = d3.select("body")
                        .append("div")
                        .style("position", "absolute")
                        .style("visibility", "hidden")
                        .style("background", "rgba(255, 255, 255, 0.9)")
                        .style("padding", "4px")
                        .style("border-radius", "2px")
                        .style("font-size", "12px")
                        .style("color", "#333");
                    let momeshLayer = currsvg.append("g").attr("id", "momesh layer").raise();
                    let momesh = momeshLayer.append("path")
                        .attr("class", "mouseover_outline")
                        .style("stroke", "black")
                        .style("stroke-width", 3)
                        .attr("d", "");

                    currsvg.append("path").datum(divisionsMesh)
                        .attr("class", "outline")
                        .attr("d", path)


                    currsvg.selectAll(`path.division-${svg.svg}`)
                        .data(divisions.features)
                        .join("path")
                        .attr("class", `division division-${svg.svg}`)
                        .style("fill", color)
                        .style("storke", "none")
                        .style("opacity", d => opacityMap[d.properties.NAME])
                        .lower()
                        .attr("d", path)
                        .on("mouseover", function (event, d) {
                            
                            const divisionName = d.properties.NAME;
                            var mo = topojson.mesh(us, us.objects.data, function (a, b) {
                                return a.properties.NAME === divisionName || b.properties.NAME === divisionName;
                            })
                            momesh.datum(mo).attr("d", path);
                            const currOpacity = opacityMap[d.properties.NAME];


                            tooltip
                                .style("visibility", "visible")
                                .html(`Division: ${d.properties.NAME} <br> Average: ${Math.round(currDivisionDic[d.properties.NAME].average)} <br> Opacty: ${currOpacity}` 
                                );
                               
                        })
                        .on("mousemove", function (event) {
                            tooltip
                                .style("top", `${event.pageY + 10}px`)
                                .style("left", `${event.pageX + 10}px`)
                                ;
                        })
                        .on(
                            "mouseout", function (event, d) {
                                d3.select(this).attr("opacity", 0.7)
                                    .transition()
                                    .duration(100)
                                    .attr("stroke", "#ffffff")
                                    .attr("wtroke-width", 1)

                                tooltip.style("visibility", "hidden")
                                momesh.attr("d", "");
                            })

                    



                });

            }
            requestData();

        }


        function updateMap(combinedData_map, color) {

            Array.from(map_svgElements).forEach(svg => {
                const svg_op = document.querySelector(`#${svg}`);
                while (svg_op.firstChild) {
                    svg_op.removeChild(svg_op.firstChild);
                }
            });

            svg_data = Array.from(map_svgElements).map((svg, index) => ({
                svg: svg,
                data: combinedData_map[index]
            }));

            drawMap(svg_data, color)
        }
        


    </script>




</body>

</html>