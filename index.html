<html>


<head>
    <title>INFO 3300 - project1</title>

    <script src="https://d3js.org/d3.v7.min.js">

    </script>
    <style>
        body {
            font-family: 'Open Sans', sans-serif;
        }

        .histogram {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            width: 100%;
            margin: auto;
        }

        .histogram svg {
            border: 1px solid #333;
        }

        .slider-line {
            stroke: #d3d3d3;
            stroke-width: 6;
            stroke-linecap: round;
        }

        .tick-text {
            font-size: 14px;
            fill: #333;
        }

        .slider-handle {
            fill: #4CAF50;
            stroke: #ffffff;
            stroke-width: 2;
            cursor: pointer;
        }

        .slider-handle:hover {
            fill: #388E3C;
        }

        #scatter-legend {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 10px;
            font-family: 'Open Sans', sans-serif;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 3px;
        }

        .scatter-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }
    </style>
</head>

<body>
    <!-- Basic HTML -->
    <h1>US Building Energy Consumption Analysis</h1>
    <p id="member">Amber Su, Chi Zhang, Kewei Xu</p>


    <div class="radio-group">
        <label>
            <input type="radio" name="energyMetric" value="NormalizedGasKWh">
            NormalizedGasKWh
        </label>
        <label>
            <input type="radio" name="energyMetric" value="NormalizedElecKWh">
            NormalizedElecKWh
        </label>
        <label>
            <input type="radio" name="energyMetric" value="NormalizedHeatKWh">
            NormalizedHeatKWh
        </label>
        <label>
            <input type="radio" name="energyMetric" value="NormalizedCoolKWh">
            NormalizedCoolKWh
        </label>
    </div>

    <div class="histogram">
        <svg id="hist1" width="800" height="300">
        </svg>
        <svg id="hist2" width="800" height="300">
        </svg>
    </div>


    <div id="slider-container"></div>

    <div>
        <label for="xSelect">X-axis:</label>
        <select id="scatter-xSelect" onchange="updateAxes()">
            <option value="NormalizedGasKWh">Normalized Gas (kWh)</option>
            <option value="NormalizedElecKWh">Normalized Electricity (kWh)</option>
            <option value="NormalizedHeatKWh">Normalized Heat (kWh)</option>
            <option value="NormalizedCoolKWh">Normalized Cooling (kWh)</option>
            <option value="SQM">Building Area </option>
        </select>

    </div>

    <div class="scatter-row">
        <svg id="scatter-cbecs" width="800" height="600"></svg>
        <svg id="scatter-recs" width="800" height="600"></svg>
    </div>


    <!-- Script -->
    <!-- Global Script -->
    <script>


        async function loadData() {
            const cbecs = await d3.csv("Data/cleaned_cbecs.csv", d3.autoType);
            const recs = await d3.csv("Data/cleaned_recs.csv", d3.autoType);
            return { cbecs, recs };
        }

        //FOR both histogram and map
        const colorMap = {
                "NormalizedGasKWh": "#ed9352",
                "NormalizedElecKWh": "#ffc815",
                "NormalizedHeatKWh": "#c00000",
                "NormalizedCoolKWh": "#6893ee"
        };

        //NOTE: This should be managed globally to get the input from user
        //For both RECS and CBECS
        var CommonFilters = {};


        function selectRange(data, key, min, max) {
            return data[key] >= min && data[key] <= max;
        }

        function setMinMaxFilter(key, min, max) {
            CommonFilters[key] = function (data) {
                return data[key] >= min && data[key] <= max;
            };
        }

        //Selected data based on the filters
        function selectData(data, filters) {
            return data.filter(d => {
                passed = true;
                Object.values(CommonFilters).forEach(filter => {
                    passed = passed && filter(d);
                });
                return passed;
            });
        }

        //setInitialFilter
        setMinMaxFilter("YRCONC", 0, 4);
        setMinMaxFilter("SQM", 0, 50000);


    </script>

    <!-- histogram Plot -->
    <script id="histogram">

        var svg_hist1 = d3.select("#hist1");
        const hist_width = svg_hist1.attr("width");
        const hist_height = svg_hist1.attr("height");
        const hist_margin = { top: 20, right: 20, bottom: 20, left: 50 };
        const hist_innerWidth = hist_width - hist_margin.left - hist_margin.right;
        const hist_innerHeight = hist_height - hist_margin.top - hist_margin.bottom;
        const hist_svgElements = ["hist1", "hist2"]



        function HistoData(data, xRange, numBins = 60) {

            let histogram = d3.histogram()
                .domain(xRange)
                .thresholds(d3.range(xRange[0], xRange[1], (xRange[1] - xRange[0]) / numBins));

            let counts = histogram(data);

            return counts;
        }


        function drawHistogram(svg_data_dict, color) {

            const xRange = [0, 600];

            var countsArray = svg_data_dict.map(d => HistoData(d.data, xRange, 60));

            const xScale = d3.scaleLinear()
                .domain(xRange)
                .range([0, hist_innerWidth]);

            const xAxis = d3.axisBottom(xScale);


            svg_data_dict.forEach((d, i) => {
                //let yRanges = countsArray.map(c => d3.extent(c, d => d.length));

                const svg_id = d.svg;
                var data = d.data;
                var chartData = countsArray[i];

                var yRange = d3.extent(chartData, d => d.length);
                var yScale = d3.scaleLinear()
                    .domain([0, yRange[1]])
                    .range([hist_innerHeight, 0]);

                var yAxis = d3.axisLeft(yScale);

                //chartData = chartData.filter(d => d.length > 50);

                console.log(chartData);

                const svg = d3.select(`#${svg_id}`);

                console.log(svg);

                const chartArea = svg.append("g")
                    .attr("transform", `translate(${hist_margin.left}, ${hist_margin.top})`);


                svg.append("g")
                    .attr("class", "hist_axis")
                    .attr("transform", `translate(${hist_margin.left}, ${hist_innerHeight + hist_margin.top})`)
                    .call(xAxis);

                svg.append("g")
                    .attr("class", "hist_axis")
                    .attr("transform", `translate(${hist_margin.left}, ${hist_margin.top})`)
                    .call(yAxis);

                const tooltip = d3.select("body")
                    .append("div")
                    .style("position", "absolute")
                    .style("visibility", "hidden")
                    .style("background", "rgba(255, 255, 255, 0.9)")
                    .style("padding", "4px")
                    .style("border-radius", "2px")
                    .style("font-size", "12px")
                    .style("color", "#333");


                chartArea.selectAll("rect.hist").data(chartData)
                    .join("rect")
                    .attr("class", "hist")
                    .attr("x", d => xScale(d.x0) + 1)
                    .attr("y", d => yScale(d.length))
                    .attr("width", d => xScale(d.x1) - xScale(d.x0))
                    .attr("height", d => yScale(0) - yScale(d.length))
                    .attr("fill", color)
                    .attr("opacity", 0.7)
                    .attr("stroke", "#ffffff")
                    .attr("stroke-width", 1)
                    .on("mouseover", function (event, d) {
                        d3.select(this).attr("opacity", 1)
                            .transition()
                            .duration(100);

                        tooltip
                            .style("visibility", "visible")
                            .html(`Count: ${d.length} <br> Range: ${d.x0} - ${d.x1} kWh/m&sup2`);
                    })
                    .on("mousemove", function (event) {
                        tooltip
                            .style("top", `${event.pageY + 10}px`)
                            .style("left", `${event.pageX + 10}px`);
                    })
                    .on(
                        "mouseout",
                        function (event, d) {
                            d3.select(this).attr("opacity", 0.7)
                                .transition()
                                .duration(100)
                                .attr("stroke", "#ffffff")
                                .attr("stroke-width", 1)

                            tooltip.style("visibility", "hidden");
                        }
                    )

            })

        }


        function updateHistogram(ComData,ResData, value) {
            color = colorMap[value];
            const combinedData = [ComData.map(d => d[value]), ResData.map(d => d[value])];
            Array.from(hist_svgElements).forEach(svg => {
                const svg_op = document.querySelector(`#${svg}`);
                while (svg_op.firstChild) {
                    svg_op.removeChild(svg_op.firstChild);
                }
            });

            svg_data = Array.from(hist_svgElements).map((svg, index) => ({
                svg: svg,
                data: combinedData[index]
            }));

            drawHistogram(svg_data, color);
        }



    </script>

    <!-- Script -->
    <script id="graph-load">
        loadData().then(data => {
            //GLOBAL INTIAL CONFIGURATION 
            var visDataKey = "NormalizedElecKWh";


            const { cbecs, recs } = data;

            var filtered_cbecs = cbecs;
            var filtered_recs = recs;

            console.log(cbecs);


            //SCATTER PLOT ONLY
            let scatterXVar = "NormalizedGasKWh";
            let scatterYVar = "NormalizedElecKWh";
            let scatterColorMetric = "DIVISION";

            d3.selectAll(".radio-group input[type='radio']")
                .on("click", function () {
                    const selectedValue = d3.select(this).attr("value");
                    scatterYVar = selectedValue; 
                    selectValue(selectedValue); 
                });

            d3.select("#scatter-xSelect").on("change", function () {
                scatterXVar = d3.select(this).property("value"); 
                updateAllScatterPlots(); 
            });

            const colorScale = d3.scaleOrdinal()
                .domain([...new Set([...cbecs.map(d => d.DIVISION), ...recs.map(d => d.DIVISION)])])
                .range(d3.schemeCategory10);

            const scatterConfigs = [
                { id: "scatter-cbecs", title: "Commercial Building", data: filtered_cbecs },
                { id: "scatter-recs", title: "Residential Building", data: filtered_recs }
            ];

            const scatterContexts = scatterConfigs.map(config =>
                drawScatter(config.id, config.title, config.data)
            );
            //END OF SCATTER PLOT ONLY

            

            function updateFilter(){
                filtered_cbecs = selectData(cbecs, CommonFilters);
                filtered_recs = selectData(recs, CommonFilters);
                updateHistogram(filtered_cbecs,filtered_recs, visDataKey);
            }
            
            
            //MAYBE TURN EVEYRTHING INTO VARIABLE AND MOVE OUT OF GLOBAL
            function updateAllScatterPlots() {
                const highlightedDivision = 3; // need to take Chi's input here!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

                scatterContexts.forEach((context, index) => {
                    updateScatter(
                        context,
                        scatterConfigs[index].data,
                        scatterXVar,
                        scatterYVar,
                        colorScale,
                        highlightedDivision,
                        scatterColorMetric 
                    );
                });
            }

            function selectValue(value) {
                visDataKey = value;
                
                filtered_cbecs = filtered_cbecs.filter(d => d[visDataKey] < 600);
                filtered_recs= filtered_recs.filter(d => d[visDataKey] < 600);

                
                updateHistogram(filtered_cbecs,filtered_recs, visDataKey);
                updateAllScatterPlots();
            }



            //global controller (must be in scope)

            function drawSlider(){
                const slider_width = 500;
                const slider_height = 100;
                const slider_margin = { top: 20, right: 40, bottom: 50, left: 30 };
                const areaExtent = [0,50000];

                const area_slider = d3.select("#slider-container")
                    .append("svg")
                    .attr("id", "area_slider")
                    .attr("width", slider_width)
                    .attr("height", slider_height);

                const areaScale = d3.scaleLinear()
                    .domain([0,1])
                    .range([slider_margin.left, slider_width - slider_margin.right]);
                    
                const arealabels = [0, 0.2, 0.4, 0.6, 0.8, 1];
                area_slider.selectAll(".area-tick-text")
                    .data(arealabels)
                    .join("text")
                    .attr("class", "area-tick-text")
                    .attr("x", d => areaScale(d))
                    .attr("y", slider_height / 2 + 30)
                    .attr("text-anchor", "middle")
                    .text(d => d * 50000);

                area_slider.append("line")
                    .attr("class", "slider-line")
                    .attr("x1", slider_margin.left)
                    .attr("x2", slider_width - slider_margin.right)
                    .attr("y1", slider_height / 2)
                    .attr("y2", slider_height / 2);

                const coloredLine = area_slider.append("line")
                    .attr("class", "colored-line")
                    .attr("x1", areaScale(0))
                    .attr("x2", areaScale(1))
                    .attr("y1", slider_height / 2)
                    .attr("y2", slider_height / 2)
                    .attr("stroke", "steelblue") 
                    .attr("stroke-width", 4);

                let startingPos = [0, 1];


                const area_handles = area_slider.selectAll(".area-slider-handle")
                    .data([0,1])
                    .enter()
                    .append("circle")
                    .attr("class", "area-slider-handle")
                    .attr("r", 10)
                    .attr("cx", d => areaScale(startingPos[d]))
                    .attr("cy", slider_height / 2)
                    .call(d3.drag()
                        .on("drag", function (event,d) {
                            console.log(d);

                            
                            var newPos = areaScale.invert(event.x);
                            
                            if (d === 0) {
                                newPos = Math.min(newPos, startingPos[1] - 0.01);
                            } else if (d === 1) {
                                newPos = Math.max(newPos, startingPos[0] + 0.01);
                            }
                            if (newPos > 1){
                                newPos = 1;
                            }else if (newPos < 0){
                                newPos = 0;
                            }

                            startingPos[d] = newPos;


                            d3.select(this).attr("cx", areaScale(newPos));

                            coloredLine
                                .attr("x1", areaScale(startingPos[0]))
                                .attr("x2", areaScale(startingPos[1]));
                                
                            
                            //updateRangeText();
                        })
                        .on("end", function(event, d) {
                            setMinMaxFilter("SQM", startingPos[0] * 50000, startingPos[1] * 50000);
                            updateFilter();
                            //updateHistogram(combinedData, colorMap[value]);
                            //updateAllScatterPlots();
                        })
                );


                const yrtickLabels = ["Pre 1960", "1960", "1980", "2000", "Post 2000"];
                const yrticks = d3.range(0, 5); 
                
                const yrsvg = d3.select("#slider-container")
                    .append("svg")
                    .attr("width", slider_width)
                    .attr("height", slider_height);
                
                const yrxScale = d3.scaleLinear()
                    .domain([0, yrticks.length - 1])
                    .range([slider_margin.left, slider_width - slider_margin.right]);
                
                yrsvg.append("line")
                    .attr("class", "slider-line")
                    .attr("x1", yrxScale(0))
                    .attr("x2", yrxScale(yrticks.length - 1))
                    .attr("y1", slider_height / 2)
                    .attr("y2", slider_height / 2);
                
                yrsvg.selectAll(".yr-tick-text")
                    .data(yrtickLabels)
                    .enter()
                    .append("text")
                    .attr("class", "yr-tick-text")
                    .attr("x", (d, i) => yrxScale(i))
                    .attr("y", slider_height / 2 + 30)
                    .attr("text-anchor", "middle")
                    .text(d => d);
                
                let handlePositions = [0, 4];
                
                yrsvg.selectAll(".slider-handle")
                    .data([0, 1])
                    .enter()
                    .append("circle")
                    .attr("class", "slider-handle")
                    .attr("r", 10)
                    .attr("cx", d => yrxScale(handlePositions[d]))
                    .attr("cy", slider_height / 2)
                    .call(d3.drag()
                    .on("drag", function (event, d) {
                        const newPos = Math.max(0, Math.min(yrticks.length - 1, Math.round(yrxScale.invert(event.x))));
                        if (d === 0 && newPos >= handlePositions[1]) {
                            handlePositions[d] = handlePositions[1] - 1;
                        } else if (d === 1 && newPos <= handlePositions[0]) {
                            handlePositions[d] = handlePositions[0] + 1;
                        } else {
                            handlePositions[d] = newPos;
                        }
                        d3.select(this).attr("cx", yrxScale(handlePositions[d]));
                        setMinMaxFilter("YRCONC", handlePositions[0], handlePositions[1]);
                        updateFilter();
                    })
                    );
            }

            selectValue(visDataKey);
            drawSlider();
        });
    </script>

    <script>
        
        
        

    </script>


    <!-- Slider Script -->
    <script id="controller" type="module">
        const width = 500;
        const height = 100;
        const slider_margin = { top: 20, right: 40, bottom: 50, left: 30 };
        
   
    </script>



    <!-- Scatter Plot Script -->
    <script id="scatter">
        function drawScatter(id, title, data) {
            const svg = d3.select(`#${id}`);
            const width = +svg.attr("width");
            const height = +svg.attr("height");
            const margin = { top: 50, right: 30, bottom: 40, left: 50 };
            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;

            const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

            svg.append("text")
                .attr("x", width / 2)
                .attr("y", margin.top / 2)
                .attr("text-anchor", "middle")
                .style("font-size", "16px")
                .text(title);

            const xScale = d3.scaleLinear().range([0, innerWidth]);
            const yScale = d3.scaleLinear().range([innerHeight, 0]);

            const xAxisGroup = g.append("g").attr("transform", `translate(0,${innerHeight})`);
            const yAxisGroup = g.append("g");

            return {
                g,
                xScale,
                yScale,
                xAxisGroup,
                yAxisGroup,
                innerWidth,
                innerHeight,
                margin
            };
        }
        function updateScatter(context, data, xVar, yVar, colorScale, highlightedDivision, colorMetric) {
            const { g, xScale, yScale, xAxisGroup, yAxisGroup } = context;

            const filteredData = data.filter(d =>
                Number.isFinite(d[xVar]) && Number.isFinite(d[yVar])
            );

            xScale.domain(d3.extent(filteredData, d => d[xVar])).nice();
            yScale.domain(d3.extent(filteredData, d => d[yVar])).nice();

            xAxisGroup.call(d3.axisBottom(xScale).ticks(6).tickFormat(d3.format(".2s")));
            yAxisGroup.call(d3.axisLeft(yScale).ticks(6).tickFormat(d3.format(".2s")));

            const circles = g.selectAll("circle")
                .data(filteredData, d => d[colorMetric]);

            circles.enter().append("circle")
                .merge(circles)
                .attr("cx", d => xScale(d[xVar]))
                .attr("cy", d => yScale(d[yVar]))
                .attr("r", 4)
                .attr("fill", d =>
                    d[colorMetric] === highlightedDivision
                        ? colorScale(d[colorMetric])
                        : "#d3d3d3"
                )
                .attr("stroke", d =>
                    d[colorMetric] === highlightedDivision
                        ? "white"
                        : "none"
                )
                .attr("opacity", d =>
                    d[colorMetric] === highlightedDivision ? 1 : 0.3);

            circles.exit().remove();

            g.selectAll("circle")
                .filter(d => d[colorMetric] === highlightedDivision)
                .each(function () {
                    this.parentNode.appendChild(this);
                });
        }


        function getColorScale(data, metric) {
            const uniqueValues = [...new Set(data.map(d => d[metric]).filter(d => d !== undefined))];
            return d3.scaleOrdinal()
                .domain(uniqueValues)
                .range(d3.schemeCategory10);
        }
    </script>




</body>

</html>