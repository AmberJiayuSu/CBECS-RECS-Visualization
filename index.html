<html>


<head>
    <title>INFO 3300 - project1</title>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>

    <style>
        body {
            font-family: 'Open Sans', sans-serif;
            margin: 0;
            padding: 0;
        }

        .title {
            font-size: 12px;
            font-weight: 400;
            margin: 0;
            padding: 0;
        }

        .layout-container {
            display: flex;
            flex-direction: row;
            gap: 20px;
            width: 100%;
            height: 100%;
            padding: 20px;
            box-sizing: border-box;
        }

        .unselectable {
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            -moz-user-select: none;
        }

        .toolbar {
            flex: 2;
            display: flex;
            flex-direction: column;
            gap: 20px;

            max-width: 300px;
            height: 840px;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .toolbar-title {
            font-size: 18px;
            font-weight: 600;
            margin-top: 10px;
            margin-bottom: 10px;
            padding: 0;
        }

        .radio-group label {
            display: block;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .dropdown-container {
            display: flex;
            flex-direction: column;
            width: 90%;
            gap: 10px;
        }

        select {
            padding: 5px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 3px;
            width: 100%;
        }

        .column {
            flex: 4;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }



        .map-container,
        .graph-container {
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }


        .histogram {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            width: 100%;
            margin: auto;
        }

        .slider-line {
            stroke: #d3d3d3;
            stroke-width: 6;
            stroke-linecap: round;
        }

        .area-tick-text,
        .yr-tick-text {
            font-size: 12px;
            fill: #333;
        }

        .slider-handle {
            fill: #4CAF50;
            stroke: #ffffff;
            stroke-width: 2;
            cursor: pointer;
        }

        .slider-handle:hover {
            fill: #388E3C;
        }

        #scatter-legend {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 10px;
            font-family: 'Open Sans', sans-serif;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 3px;
        }

        .scatter-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .division {

            fill: lightgrey;
        }

        .outline {
            fill: none;
            stroke: rgb(0, 0, 0);
            stroke-width: 1px;
        }

        .graticule {
            fill: none;
            stroke: grey;
            stroke-width: 1px;
        }

        .tooltip {
            pointer-events: none;
        }

        .mouseover_outline {
            pointer-events: none;
            fill: none;
        }

        .path-selected {
            stroke-width: 2.5;
        }
    </style>
</head>

<body>
    <!-- Basic HTML -->
    <h1>US Building Energy Consumption Analysis</h1>
    <p id="member">Amber Su, Chi Zhang, Curtis Xu</p>






    <div class="layout-container">
        <!-- Toolbar Column -->
        <div class="toolbar">
            <div class="radio-group">
                <p class ='toolbar-title'>All Graph Y-axis</p>
                <label>
                    <input type="radio" name="energyMetric" value="NormalizedGasKWh">
                    Normalized Gas (kWh)
                </label>
                <label>
                    <input type="radio" name="energyMetric" value="NormalizedElecKWh">
                    Normalized Electricity (kWh)
                </label>
                <label>
                    <input type="radio" name="energyMetric" value="NormalizedHeatKWh">
                    Normalized Heat (kWh)
                </label>
                <label>
                    <input type="radio" name="energyMetric" value="NormalizedCoolKWh">
                    Normalized Cooling (kWh)
                </label>
            </div>

            <div class="dropdown-container">
                <p class ='toolbar-title'>Scatter Plot X-axis</p>

                <select id="scatter-xSelect" onchange="updateAxes()">
                    <option value="NormalizedGasKWh">Normalized Gas (kWh)</option>
                    <option value="NormalizedElecKWh">Normalized Electricity (kWh)</option>
                    <option value="NormalizedHeatKWh">Normalized Heat (kWh)</option>
                    <option value="NormalizedCoolKWh">Normalized Cooling (kWh)</option>
                    <option value="SQM">Building Area</option>
                </select>
            </div>
            <div id="slider-row" style="display: flex; gap: 10px; align-items: center;">
                <div id="slider-container-area">
                    <p class ='toolbar-title'>Area Range</p>
                    <svg id="area-slider" width="120" height="400"></svg>
                </div>
                <div id="slider-container-year">
                    <p class ='toolbar-title'>Year Range</p>
                    <svg id="year-slider" width="120" height="400"></svg>
                </div>
            </div>


        </div>


        <!-- Main Content -->
        <div class="column">
            <div id="commercial-map" class="map-container">
                <svg id="map1" height="400" width="400"></svg>
            </div>
            <div id="residential-map" class="map-container">
                <svg id="map2" height="400" width="400"></svg>
            </div>
        </div>

        <div class="column">
            <div id="commercial-histogram" class="graph-container">
                <svg id="hist1" width="650" height="400"></svg>
            </div>

            <div id="residential-histogram" class="graph-container">
                <svg id="hist2" width="650" height="400"></svg>
            </div>

        </div>

        <div class="column">
            <div id="commercial-scatter" class="graph-container">
                <svg id="scatter-cbecs" width="650" height="400"></svg>
            </div>
            <div id="residential-scatter" class="graph-container">
                <svg id="scatter-recs" width="650" height="400"></svg>
            </div>
        </div>
    </div>




    <!-- Script -->
    <!-- Global Script -->
    <script>


        async function loadData() {
            const cbecs = await d3.csv("Data/cleaned_cbecs.csv", d3.autoType);
            const recs = await d3.csv("Data/cleaned_recs.csv", d3.autoType);
            return { cbecs, recs };
        }

        //FOR both histogram and map
        const colorMap = {
            "NormalizedGasKWh": "#ed9352",
            "NormalizedElecKWh": "#ffc815",
            "NormalizedHeatKWh": "#c00000",
            "NormalizedCoolKWh": "#6893ee"
        };



        //NOTE: This should be managed globally to get the input from user
        //For both RECS and CBECS
        var CommonFilters = {};
        var selectedDivisions = [];


        function selectRange(data, key, min, max) {
            return data[key] >= min && data[key] <= max;
        }

        function setMinMaxFilter(key, min, max) {
            CommonFilters[key] = function (data) {
                return data[key] >= min && data[key] <= max;
            };
        }

        function setMatchFilter(key, value) {
            if (selectedDivisions.includes(value)) {
                selectedDivisions = selectedDivisions.filter(d => d !== value);

            } else {
                selectedDivisions.push(value);
            }

            CommonFilters[key] = function (data) {
                return selectedDivisions.includes(data[key]);
            };
        }

        //Selected data based on the filters
        function selectData(data, filters) {
            return data.filter(d => {
                passed = true;
                Object.values(CommonFilters).forEach(filter => {
                    passed = passed && filter(d);
                });
                return passed;
            });
        }

        const graph_note = ["No Commercial Building Data within the Filtered Range", "No Residential Building Data within the Filtered Range"]



        //setInitialFilter
        setMinMaxFilter("YRCONC", 0, 4);
        setMinMaxFilter("SQM", 0, 50000);
        //setMatchFilter("DIVISION", [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);

    </script>

    <!-- histogram Plot -->
    <script id="histogram">

        const svg_hist1 = d3.select("#hist1");
        //const svg_hist2 = d3.select("#hist2");
        const hist_width = svg_hist1.attr("width");
        const hist_height = svg_hist1.attr("height");
        const hist_margin = { top: 40, right: 20, bottom: 20, left: 50 };
        const hist_innerWidth = hist_width - hist_margin.left - hist_margin.right;
        const hist_innerHeight = hist_height - hist_margin.top - hist_margin.bottom;
        const hist_svgElements = ["hist1", "hist2"]

        const hist_title = ["Distribution of Commercial Buildings by Energy Consumption", "Distribution of Residential Buildings by Energy Consumption"]


        function HistoData(data, xRange, numBins = 60) {

            let histogram = d3.histogram()
                .domain(xRange)
                .thresholds(d3.range(xRange[0], xRange[1], (xRange[1] - xRange[0]) / numBins));

            let counts = histogram(data);

            return counts;
        }


        function drawHistogram(svg_data_dict, color) {

            const xRange = [0, 600];

            var countsArray = svg_data_dict.map(d => HistoData(d.data, xRange, 60));

            const xScale = d3.scaleLinear()
                .domain(xRange)
                .range([0, hist_innerWidth]);

            const xAxis = d3.axisBottom(xScale);


            svg_data_dict.forEach((d, i) => {
                //let yRanges = countsArray.map(c => d3.extent(c, d => d.length));

                const svg_id = d.svg;
                var data = d.data;
                var chartData = countsArray[i];

                const svg = d3.select(`#${svg_id}`);

                var yRange = d3.extent(chartData, d => d.length);
                var yScale = d3.scaleLinear()
                    .domain([0, yRange[1]])
                    .range([hist_innerHeight, 0]);

                var yAxis = d3.axisLeft(yScale);

                //chartData = chartData.filter(d => d.length > 50);

                svg.append("g")
                    .append("text")
                    .attr("class", "title")
                    .attr("transform", `translate(${hist_width / 2}, ${hist_margin.top / 2})`)
                    .attr("text-anchor", "middle")
                    .text(hist_title[i]);


                const chartArea = svg.append("g")
                    .attr("transform", `translate(${hist_margin.left}, ${hist_margin.top})`);


                svg.append("g")
                    .attr("class", "hist_axis")
                    .attr("transform", `translate(${hist_margin.left}, ${hist_innerHeight + hist_margin.top})`)
                    .call(xAxis);

                svg.append("g")
                    .attr("class", "hist_axis")
                    .attr("transform", `translate(${hist_margin.left}, ${hist_margin.top})`)
                    .call(yAxis);

                if (d.data.length === 0) {
                    svg.append("text")
                        .attr("class", "note")
                        .attr("id", `zero`)
                        .attr("transform", `translate(${hist_width / 2}, ${hist_height / 2})`)
                        .attr("text-anchor", "middle")
                        .text(graph_note[i])
                        .attr("font-size", "12px")
                        .attr("visibility", "visible");


                } else {


                    const tooltip = d3.select("body")
                        .append("div")
                        .style("position", "absolute")
                        .style("visibility", "hidden")
                        .style("background", "rgba(255, 255, 255, 0.9)")
                        .style("padding", "4px")
                        .style("border-radius", "2px")
                        .style("font-size", "12px")
                        .style("color", "#333");


                    chartArea.selectAll("rect.hist").data(chartData)
                        .join("rect")
                        .attr("class", "hist")
                        .attr("x", d => xScale(d.x0) + 1)
                        .attr("y", d => yScale(d.length))
                        .attr("width", d => xScale(d.x1) - xScale(d.x0))
                        .attr("height", d => yScale(0) - yScale(d.length))
                        .attr("fill", color)
                        .attr("opacity", 0.7)
                        .attr("stroke", "#ffffff")
                        .attr("stroke-width", 1)
                        .on("mouseover", function (event, d) {
                            d3.select(this).attr("opacity", 1)
                                .transition()
                                .duration(100);

                            tooltip
                                .style("visibility", "visible")
                                .html(`Count: ${d.length} <br> Range: ${d.x0} - ${d.x1} kWh/m&sup2`);
                        })
                        .on("mousemove", function (event) {
                            tooltip
                                .style("top", `${event.pageY + 10}px`)
                                .style("left", `${event.pageX + 10}px`);
                        })
                        .on(
                            "mouseout",
                            function (event, d) {
                                d3.select(this).attr("opacity", 0.7)
                                    .transition()
                                    .duration(100)
                                    .attr("stroke", "#ffffff")
                                    .attr("stroke-width", 1)

                                tooltip.style("visibility", "hidden");
                            }
                        )
                }


            })

        }


        function updateHistogram(ComData, ResData, value) {

            color = colorMap[value];
            const combinedData = [ComData.map(d => d[value]), ResData.map(d => d[value])];
            Array.from(hist_svgElements).forEach(svg => {
                const svg_op = document.querySelector(`#${svg}`);
                while (svg_op.firstChild) {
                    svg_op.removeChild(svg_op.firstChild);
                }
            });

            svg_data = Array.from(hist_svgElements).map((svg, index) => ({
                svg: svg,
                data: combinedData[index]
            }));

            drawHistogram(svg_data, color);
        }



    </script>

    <!-- Script -->
    <script id="graph-load">
        loadData().then(data => {
            //GLOBAL INTIAL CONFIGURATION 
            var visDataKey = "NormalizedElecKWh";
            const { cbecs, recs } = data;
            var filtered_cbecs = cbecs;
            var filtered_recs = recs;

            d3.selectAll(".radio-group input[type='radio']")
                .on("click", function () {
                    const selectedValue = d3.select(this).attr("value");
                    scatterYVar = selectedValue;
                    selectValue(selectedValue);
                });

            //SCATTER PLOT ONLY
            let scatterXVar = "NormalizedGasKWh";
            let scatterYVar = "NormalizedElecKWh";

            d3.select("#scatter-xSelect").on("change", function () {
                scatterXVar = d3.select(this).property("value");
                updateAllScatterPlots();
            });

            const scatterConfigs = [
                { id: "scatter-cbecs", title: "Scatter Plot of Commercial Buildings by Energy Consumption" },
                { id: "scatter-recs", title: "Scatter Plot of Residential Buildings by Energy Consumption" }
            ];

            const scatterContexts = scatterConfigs.map(config =>
                drawScatter(config.id, config.title)
            );

            function updateAllScatterPlots() {
                let highlightedDivision = []; // need to take Chi's input here!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

                scatterContexts.forEach((context, index) => {
                    const filteredData = index === 0 ? filtered_cbecs : filtered_recs; // Use filtered datasets
                    updateScatter(
                        context,
                        filteredData, // Pass filtered data
                        scatterXVar,
                        scatterYVar,
                        highlightedDivision,
                    );
                });
            }

            //END OF SCATTER PLOT ONLY



            //UPDATE FOR FILTERS
            function updateFilter() {
                filtered_cbecs = selectData(cbecs, CommonFilters);
                filtered_recs = selectData(recs, CommonFilters);
                updateHistogram(filtered_cbecs, filtered_recs, visDataKey);
                updateAllScatterPlots();

                //CHI PUT YOUR GRAPH UPDATE HERE

                //IDEALLY IT SHOULD JUST CHANGE THE COLOR, NOT REDRAW EVERYTHING
            }

            //UPDATE FOR WHICH VALUE TO DISPLAY
            function selectValue(value) {
                visDataKey = value;


                updateHistogram(filtered_cbecs, filtered_recs, visDataKey);
                updateAllScatterPlots();

                //CHI: PUT YOUR GRAPH UPDATE HRE

                //HERE IT SHOULD UPDATE FOR WHICH DATA TO SHOW (GAS, ELEC, HEAT, COOL)
                //IDEALLY IT SHOULD JUST CHANGE THE COLOR, NOT REDRAW EVERYTHING
                const combinedData_map = [filtered_cbecs.map(d => ({ value: d[value], division: d.DIVISION })),
                filtered_recs.map(d => ({ value: d[value], division: d.DIVISION }))];

                updateMap(combinedData_map, colorMap[value], updateFilter);
            }

            //global controller (must be in scope)
            //LISTEN TO EVENT AND UPDATE FILTER
            //WILL CALL updateFilter() WITH UPDATED FILTER
            function drawSliders() {
                drawAreaSlider();
                drawYearSlider();
            }
            function drawAreaSlider() {
    const slider_width = 80;
    const slider_height = 400;
    const slider_margin = { top: 40, right: 20, bottom: 40, left: 40 };
    const areaExtent = [50, 50000];

    const areaScale = d3.scaleLog()
        .domain(areaExtent)
        .range([slider_margin.top, slider_height - slider_margin.bottom]);

    const area_slider = d3.select("#area-slider");

    const arealabels = [50, 500, 5000, 20000, 50000];

    area_slider.append("line")
        .attr("class", "slider-line")
        .attr("x1", slider_width / 2)
        .attr("x2", slider_width / 2)
        .attr("y1", areaScale(areaExtent[0]))
        .attr("y2", areaScale(areaExtent[1]));

    // Add tick labels with 'm²'
    area_slider.selectAll(".area-tick-text")
        .data(arealabels)
        .join("text")
        .attr("class", "area-tick-text unselectable")
        .attr("x", slider_width / 2 + 15)
        .attr("y", d => areaScale(d))
        .attr("text-anchor", "start")
        .text(d => `${d} m\u00B2`); // Append 'm²' to each label

    const coloredLine = area_slider.append("line")
        .attr("class", "colored-line")
        .attr("x1", slider_width / 2)
        .attr("x2", slider_width / 2)
        .attr("y1", areaScale(areaExtent[0]))
        .attr("y2", areaScale(areaExtent[1]))
        .attr("stroke", "steelblue")
        .attr("stroke-width", 4);

    let startingPos = [...areaExtent];

    area_slider.selectAll(".area-tick-circle")
        .data(arealabels)
        .join("circle")
        .attr("class", "area-tick-circle")
        .attr("cx", slider_width / 2)
        .attr("cy", d => areaScale(d))
        .attr("r", 4) // Small radius for the circle
        .attr("fill", "steelblue");

    area_slider.selectAll(".area-slider-handle")
        .data([0, 1])
        .enter()
        .append("circle")
        .attr("class", "area-slider-handle")
        .attr('fill', 'darkblue')
        .attr("r", 8)
        .attr("cx", slider_width / 2)
        .attr("cy", d => areaScale(startingPos[d]))
        .style("z-index", 10) // Ensure handles appear on top
        .call(d3.drag()
            .on("drag", function (event, d) {
                let newPos = areaScale.invert(event.y);
                if (d === 0) {
                    newPos = Math.max(areaExtent[0], Math.min(newPos, startingPos[1] / 1.1));
                } else if (d === 1) {
                    newPos = Math.min(areaExtent[1], Math.max(newPos, startingPos[0] * 1.1));
                }
                startingPos[d] = newPos;
                d3.select(this).attr("cy", areaScale(newPos));
                coloredLine
                    .attr("y1", areaScale(startingPos[0]))
                    .attr("y2", areaScale(startingPos[1]));
            })
            .on("end", function () {
                setMinMaxFilter("SQM", startingPos[0], startingPos[1]);
                updateFilter();
            })
        );
}

            function drawYearSlider() {
                const slider_width = 50;
                const slider_height = 400;
                const slider_margin = { top: 40, right: 20, bottom: 40, left: 40 };
                const yrtickLabels = ["Pre 1960", "1960", "1980", "2000", "Post 2000"];
                const yrticks = d3.range(0, yrtickLabels.length);

                const yearScale = d3.scaleLinear()
                    .domain([0, yrtickLabels.length - 1])
                    .range([slider_margin.top, slider_height - slider_margin.bottom]);

                const year_slider = d3.select("#year-slider");

                // Add vertical slider line
                year_slider.append("line")
                    .attr("class", "slider-line")
                    .attr("x1", slider_width / 2)
                    .attr("x2", slider_width / 2)
                    .attr("y1", yearScale(0))
                    .attr("y2", yearScale(yrtickLabels.length - 1));

                // Add tick labels
                year_slider.selectAll(".yr-tick-text")
                    .data(yrtickLabels)
                    .join("text")
                    .attr("class", "yr-tick-text unselectable")
                    .attr("x", slider_width / 2 + 15)
                    .attr("y", (d, i) => yearScale(i))
                    .attr("text-anchor", "start")
                    .text(d => d);

                const coloredLine = year_slider.append("line")
                    .attr("class", "colored-line")
                    .attr("x1", slider_width / 2)
                    .attr("x2", slider_width / 2)
                    .attr("y1", yearScale(0))
                    .attr("y2", yearScale(yrtickLabels.length - 1))
                    .attr("stroke", "steelblue")
                    .attr("stroke-width", 4);


                year_slider.selectAll(".yr-tick-circle")
                    .data(yrticks)
                    .join("circle")
                    .attr("class", "yr-tick-circle")
                    .attr("cx", slider_width / 2)
                    .attr("cy", d => yearScale(d))
                    .attr("r", 4)
                    .attr("fill", "steelblue");
                let handlePositions = [0, yrtickLabels.length - 1];

                year_slider.selectAll(".yr-slider-handle")
                    .data([0, 1])
                    .enter()
                    .append("circle")
                    .attr("class", "yr-slider-handle")
                    .attr('fill', 'darkblue')
                    .attr("r", 8)
                    .attr("cx", slider_width / 2)
                    .attr("cy", d => yearScale(handlePositions[d]))
                    .style("z-index", 10) // Ensure handles appear on top
                    .call(d3.drag()
                        .on("drag", function (event, d) {
                            let newPos = Math.max(0, Math.min(yrtickLabels.length - 1, Math.round(yearScale.invert(event.y))));
                            if (d === 0 && newPos >= handlePositions[1]) {
                                handlePositions[d] = handlePositions[1] - 1;
                            } else if (d === 1 && newPos <= handlePositions[0]) {
                                handlePositions[d] = handlePositions[0] + 1;
                            } else {
                                handlePositions[d] = newPos;
                            }
                            d3.select(this).attr("cy", yearScale(handlePositions[d]));
                            coloredLine
                                .attr("y1", yearScale(handlePositions[0]))
                                .attr("y2", yearScale(handlePositions[1]));
                        })
                        .on("end", function () {
                            setMinMaxFilter("YRCONC", handlePositions[0], handlePositions[1] - 1);
                            updateFilter();
                        })
                    );
            }

            //LATER LET'S CHECK HOW TO BEST HANDLE DIVISION SELECTIOn


            //INITIAL DRAWING HERE!
            selectValue(visDataKey);
            drawSliders();
        });
    </script>


    <!-- Scatter Plot Script -->
    <script id="scatter">

        function drawScatter(id, title) {
            const svg = d3.select(`#${id}`);
            const width = +svg.attr("width");
            const height = +svg.attr("height");
            const margin = { top: 40, right: 135, bottom: 20, left: 50 };
            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;

            const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

            svg.append("text")
                 .attr("class", "title")
                .attr("x", width / 2)
                .attr("y", margin.top / 2)
                .attr("text-anchor", "middle")
                .style("font-size", "12px")
                .text(title);

            const xScale = d3.scaleLinear().range([0, innerWidth]);
            const yScale = d3.scaleLinear().range([innerHeight, 0]);

            const xAxisGroup = g.append("g").attr("transform", `translate(0,${innerHeight})`);
            const yAxisGroup = g.append("g");

            const divisionNames = [
                '0 New England',
                '1 Middle Atlantic',
                '2 East North Central',
                '3 West North Central',
                '4 South Atlantic',
                '5 East South Central',
                '6 West South Central',
                '7 Mountain',
                '8 Pacific'];

            const scatterColorScale = d3.scaleOrdinal()
                .domain(d3.range(0, divisionNames.length))
                .range(d3.schemeTableau10);


            const legend = svg.append("g")
                .attr("class", "legend")
                .attr("transform", `translate(${width - margin.right + 20}, ${margin.top + 10})`);

            divisionNames.forEach((name, index) => {
                const legendItem = legend.append("g")
                    .attr("transform", `translate(0, ${index * 20})`);

                legendItem.append("rect")
                    .attr("width", 10)
                    .attr("height", 10)
                    .attr("fill", scatterColorScale(index));

                legendItem.append("text")
                    .attr("x", 15)
                    .attr("y", 10)
                    .attr("font-size", "10px")
                    .text(name);
            });

            return {
                g,
                xScale,
                yScale,
                xAxisGroup,
                yAxisGroup,
                innerWidth,
                innerHeight,
                margin,
            };
        }
        function updateScatter(context, data, xVar, yVar, highlightedDivision) {
    const { g, xScale, yScale, xAxisGroup, yAxisGroup, innerWidth, innerHeight } = context;

    const colorMetric = "DIVISION";
    const scatterColorScale = d3.scaleOrdinal()
        .domain(d3.range(0, 9))
        .range(d3.schemeTableau10);

    const filteredData = data.filter(d =>
        Number.isFinite(d[xVar]) &&
        Number.isFinite(d[yVar]) &&
        d[xVar] !== 0 &&
        d[yVar] !== 0
    );

    if (filteredData.length === 0) {
        g.selectAll("circle").remove();
        let warningText = g.select(".note");

        if (warningText.empty()) {
            g.append("text")
                .attr("class", "note")
                .attr("id", `zero`)
                .attr("transform", `translate(${innerWidth / 2}, ${innerHeight / 2})`)
                .attr("text-anchor", "middle")
                .attr("font-size", "10px")
                .text(graph_note[1])
                .attr("visibility", "visible");
        } else {
            warningText.attr("visibility", "visible");
        }
        return;
    }

    g.selectAll(".note").attr("visibility", "hidden");

    xScale.domain(d3.extent(filteredData, d => d[xVar])).nice();
    yScale.domain([0, 600]);

    xAxisGroup.call(d3.axisBottom(xScale).ticks(6).tickFormat(d3.format(".2s")));
    yAxisGroup.call(d3.axisLeft(yScale).ticks(6).tickFormat(d3.format(".2s")));

    const tooltip = d3.select("body").append("div")
        .attr("class", "scatter-tooltip")
        .style("position", "absolute")
        .style("background", "rgba(255, 255, 255, 0.9)")
        .style("color", "#333")
        .style("padding", "4px")
        .style("border-radius", "2px")
        .style("pointer-events", "none")
        .style("font-size", "12px")
        .style("opacity", 0);

    const circles = g.selectAll("circle")
        .data(filteredData, d => d[colorMetric]);

    circles.enter().append("circle")
        .merge(circles)
        .attr("cx", d => xScale(d[xVar]))
        .attr("cy", d => yScale(d[yVar]))
        .attr("r", 2.5)
        .attr("fill", d => {
            if (highlightedDivision === null || highlightedDivision.length === 0) {
                // No highlighted divisions, color all points
                return scatterColorScale(d[colorMetric]);
            } else {
                // Highlight only divisions in the array
                return highlightedDivision.includes(d[colorMetric])
                    ? scatterColorScale(d[colorMetric])
                    : "#d3d3d3"; // Grey out others
            }
        })
        .attr("stroke", "white")
        .attr("stroke-width", 0.5)
        .attr("opacity", d =>
            highlightedDivision !== null
                ? highlightedDivision.includes(d[colorMetric]) ? 1 : 0.8
                : 1) // Dim non-highlighted points
        .on("mouseover", (event, d) => {
            tooltip.style("opacity", 1)
                .html(`
                    <strong>${colorMetric}: </strong>${d[colorMetric]}<br>
                    <strong>${xVar}: </strong>${d[xVar].toFixed(2)}<br>
                    <strong>${yVar}: </strong>${d[yVar].toFixed(2)}
                `);
        })
        .on("mousemove", event => {
            tooltip.style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 20) + "px");
        })
        .on("mouseout", () => {
            tooltip.style("opacity", 0);
        });

    circles.exit().remove();

    g.selectAll("circle")
        .filter(d => highlightedDivision && highlightedDivision.includes(d[colorMetric]))
        .each(function () {
            this.parentNode.appendChild(this);
        });
}

    </script>

    <script id="map">

        var svg_map = d3.select("#map1");
        const map_width = svg_map.attr("width");
        const map_height = svg_map.attr("height");
        const map_margin = { top: 20, right: 20, bottom: 20, left: 20 };
        const map_Width = map_width - map_margin.left - map_margin.right;
        const map_Height = map_height - map_margin.top - map_margin.bottom;
        const map_svgElements = ["map1", "map2"]
        console.log(map_width);

        

        const map_title= ["Map of Commercial Buildings by Energy Consumption", "Map of Residential Buildings by Energy Consumption"]


        function drawMap(svg_data, color,updateFilter) {
            const requestData = async function () {
                const us = await d3.json("Data/censusDiv.topojson", d3.autoType);
                console.log("us");
                console.log(us);


                var divisions = topojson.feature(us, us.objects.data);


                var divisionsMesh = topojson.mesh(us, us.objects.data);

                var projection = d3.geoAlbersUsa().fitSize([map_Width, map_Height], divisions);
                //var projection = d3.geoAlbersUsa().fitExtent([[20, 20], [880, 580]], divisions);
                var path = d3.geoPath().projection(projection);

                let graticule = d3.geoGraticule10();



                var divisionDict = {};
                const divisionNumberName = {
                    1: "New England",
                    2: "Middle Atlantic",
                    3: "East North Central",
                    4: "West North Central",
                    5: "South Atlantic",
                    6: "East South Central",
                    7: "West South Central",
                    8: "Mountain",
                    9: "Pacific"
                }
                svg_data.forEach(set => {
                    const setSource = set.svg;
                    if (!divisionDict[setSource]) {
                        divisionDict[setSource] = {};
                    }
                    set.data.forEach(pair => {
                        const value = pair.value;
                        let division = pair.division;
                        if (typeof division === "number") {
                            division = divisionNumberName[division];
                        }
                        if (division === "Mountain North" || division === "Mountain South") {
                            division = "Mountain";
                        }

                        if (!divisionDict[setSource][division]) {
                            divisionDict[setSource][division] = { source: setSource, sum: 0, count: 0, average: 0 };
                        }
                        divisionDict[setSource][division].sum += value;
                        divisionDict[setSource][division].count += 1;
                    })

                    //average
                    Object.keys(divisionDict[setSource]).forEach(division => {
                        divisionDict[setSource][division].average = divisionDict[setSource][division].sum / divisionDict[setSource][division].count;
                    })

                })


                let extent = [];
                let extentTotal = [];

                Object.keys(divisionDict).forEach(map => {
                    const elements = Object.values(divisionDict[map]);
                    const minMax = d3.extent(elements, d => d.average)
                    extent.push(minMax);
                });


                //total extent
                extentTotal = [
                    Math.min(extent[0][0], extent[1][0]),
                    Math.max(extent[0][1], extent[1][1])
                ]
                //opacity Scale
                const opacityScale = d3.scaleQuantile()
                    .domain(extentTotal)
                    .range([1 / 6, 2 / 6, 3 / 6, 4 / 6, 5 / 6, 1]);

                const maps = {};

                const handleClick = (event, d,updateFilter) => {
                    const divisionNumber = Number(d.properties.DIVISIONCE);
                    setMatchFilter("DIVISION", divisionNumber);
                    
                    // Update ALL SVGs at once
                    d3.selectAll("svg path.division")
                        .classed("path-selected", function(pathD) {
                            return selectedDivisions.includes(Number(pathD.properties.DIVISIONCE) );
                        })
                        .style("stroke-width", function(pathD) {
                            return selectedDivisions.includes(Number(pathD.properties.DIVISIONCE)) ? "2.5" : "1";
                        })
                        .style("stroke", function(pathD) {
                            return selectedDivisions.includes(Number(pathD.properties.DIVISIONCE)) ? "black" : null;
                        });
                    updateFilter();
                };

                svg_data.forEach((svg, index) => {
                    

                    const currsvg = d3.select(`#${svg.svg}`);
                    currsvg.append("g")
                    .append("text")
                    .attr("class", "title")
                    .attr("transform", `translate(${map_width / 2}, ${map_margin.top / 2+10})`)
                    .attr("text-anchor", "middle")
                    .text(map_title[index]);

                    const currDivisionDic = divisionDict[svg.svg];

                    const opacityMap = {};
                    Object.keys(currDivisionDic).forEach(division => {
                        opacityMap[division] = opacityScale(currDivisionDic[division].average);
                    });


                    const tooltip = d3.select("body")
                        .append("div")
                        .style("position", "absolute")
                        .style("visibility", "hidden")
                        .style("background", "rgba(255, 255, 255, 0.9)")
                        .style("padding", "4px")
                        .style("border-radius", "2px")
                        .style("font-size", "12px")
                        .style("color", "#333");


                    currsvg.selectAll("path.division")
                        .data(divisions.features)
                        .join("path")
                        .attr("class", "division")
                        .style("fill", color)
                        .style("fill-opacity", d => opacityMap[d.properties.NAME])
                        .attr("d", path)
                        .on("mouseover", function (event, d) {

                            const divisionName = d.properties.NAME;
                            const currOpacity = opacityMap[d.properties.NAME];

                            d3.select(this)
                                .transition()
                                .duration(100)
                                .attr("stroke", "black")
                                .attr("stroke-width", 2);

                            tooltip
                                .style("visibility", "visible")
                                .html(`Division: ${d.properties.NAME} <br> Average: ${Math.round(currDivisionDic[d.properties.NAME].average)} <br> Opacty: ${currOpacity}`
                                );

                        })
                        .on("mousemove", function (event) {
                            tooltip
                                .style("top", `${event.pageY + 10}px`)
                                .style("left", `${event.pageX + 10}px`)
                                ;
                        })
                        .on(
                            "mouseout", function (event, d) {
                                d3.select(this)
                                    .transition()
                                    .duration(100)
                                    .attr("stroke-width", 1)

                                tooltip.style("visibility", "hidden")

                            })
                            .on("click", (event,d) => handleClick(event, d, updateFilter))
                        .raise();
                        



                    currsvg.append("path").datum(divisionsMesh)
                        .attr("class", "outline")
                        .attr("d", path)
                        .attr("stroke", "black")
                        .attr("stroke-width", 1)
                        .raise();

                });



               
                
                                
                
            }
            requestData();






        }


        function updateMap(combinedData_map, color,updateFilter) {

            Array.from(map_svgElements).forEach(svg => {
                const svg_op = document.querySelector(`#${svg}`);
                while (svg_op.firstChild) {
                    svg_op.removeChild(svg_op.firstChild);
                }
            });

            svg_data = Array.from(map_svgElements).map((svg, index) => ({
                svg: svg,
                data: combinedData_map[index]
            }));

            drawMap(svg_data, color,updateFilter);
            
        }

        function legendMap(colorScale, svgId, chunks){
            const width = map_width-50;
            const height = 30;
            const chunkWidth = width/colorScale.range().length;

            const legendGroup = d3.select(`#${svgId}`)
                                .append("g")
                                .attr("width", width)
                                .attr("height", height);

            const colors = colorScale.range();
            const legendData = colors.map(color => ({
                color,
                range: colorScale.invertExtent(color)
            }));

            

            legendGroup.selectAll("rect")
                     .data(legendData)
                     .join("rect")
                     .attr("x", (d,i) => i*chunkWidth+map_width/2-chunks/2*chunkWidth)
                     .attr("y", map_height-50)
                     .attr("width", chunkWidth)
                     .attr("height", 15)
                     .style("fill", d => d.color);

            legendGroup.selectAll("text")
                     .data(legendData)
                     .join("text")
                     .attr("x", (d,i) => i*chunkWidth+map_width/2-chunks/2*chunkWidth-7) 
                     .attr("y", map_height-15)
                     .attr("text-anchor", "start")
                     .attr("font-size", "10px")
                     .text(d =>`${Math.round(d.range[0])}`)

            const lastThreshold= legendData[legendData.length - 1].range;
            legendGroup.append("text")
                       .attr("x", map_width/2+chunks/2*chunkWidth-chunkWidth/2)
                       .attr("y", map_height-15)
                       .attr("text-anchor", "start")
                       .attr("font-size", "10px")
                       .text(`${Math.round(lastThreshold[1])}`+"(kWh)");
        }



    </script>




</body>

</html>